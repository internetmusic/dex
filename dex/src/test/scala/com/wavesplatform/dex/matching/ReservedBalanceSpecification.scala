package com.wavesplatform.dex.matching

import akka.actor.{ActorRef, Props}
import akka.pattern.ask
import akka.testkit.TestProbe
import akka.util.Timeout
import com.wavesplatform.dex.AddressActor.Command.PlaceOrder
import com.wavesplatform.dex.AddressDirectory.Envelope
import com.wavesplatform.dex.api.OrderRejected
import com.wavesplatform.dex.db.{EmptyOrderDB, TestOrderDB, WithDB}
import com.wavesplatform.dex.domain.account.PublicKey
import com.wavesplatform.dex.domain.asset.{Asset, AssetPair}
import com.wavesplatform.dex.domain.order.OrderType.{BUY, SELL}
import com.wavesplatform.dex.domain.order.{Order, OrderType}
import com.wavesplatform.dex.error.ErrorFormatterContext
import com.wavesplatform.dex.grpc.integration.clients.WavesBlockchainClient.SpendableBalanceChanges
import com.wavesplatform.dex.market.MatcherSpecLike
import com.wavesplatform.dex.model.Events.{OrderAdded, OrderCanceled, OrderExecuted}
import com.wavesplatform.dex.model.OrderBook._
import com.wavesplatform.dex.model.{LevelAgg, LimitOrder, MarketOrder, OrderHistoryStub}
import com.wavesplatform.dex.queue.{QueueEvent, QueueEventWithMeta}
import com.wavesplatform.dex.time.NTPTime
import com.wavesplatform.dex.util.getSimpleName
import com.wavesplatform.dex.{MatcherSpecBase, _}
import monix.reactive.subjects.Subject
import org.scalatest.prop.TableDrivenPropertyChecks
import org.scalatest.propspec.AnyPropSpecLike

import scala.concurrent.duration.{Duration, DurationInt}
import scala.concurrent.{Await, Future}
import scala.math.BigDecimal.RoundingMode.CEILING

/**
  * Tests for reserved balance
  *
  * This specification checks how different cases affect reserved balance.
  *
  * Test cases was generated by filtered decision table:
  *
  * Field Name          | Values                          | Description
  * -------------------------------------------------------------------
  * CounterType         | Buy, Sell                       | Submitted type will be set automatically
  * Amounts             | A_c = A_s, A_c > A_s, A_c < A_s | A_c - counter amount, A_s - submitted amount
  * CorrectedAmount     | A_corr = A, A_corr < A          | A - match amount
  * Prices              | P_c = P_s, P_c != P_s           | P_c - counter price, P_s - submitted price
  * CounterRestAmount   | 0, A_min, A_min - 1             | Rest amount after matching. A_min - minimal amount can be filled by the price
  * SubmittedRestAmount | 0, A_min, A_min - 1             | Rest amount after matching. A_min - minimal amount can be filled by the price
  *
  * CounterType | Amounts   | CorrectedAmount | Prices     | CounterRestAmount | SubmittedRestAmount
  * ------------------------------------------------------------------------------------------------
  * Buy         | A_c = A_s | A_corr = A      | P_c = P_s  | 0                 | 0
  * Sell        | A_c = A_s | A_corr = A      | P_c = P_s  | 0                 | 0
  * Buy         | A_c = A_s | A_corr = A      | P_c != P_s | 0                 | 0
  * Sell        | A_c = A_s | A_corr = A      | P_c != P_s | 0                 | 0
  * Buy         | A_c > A_s | A_corr = A      | P_c = P_s  | A_min - 1         | 0
  * Sell        | A_c > A_s | A_corr = A      | P_c = P_s  | A_min - 1         | 0
  * Buy         | A_c > A_s | A_corr = A      | P_c != P_s | A_min - 1         | 0
  * Sell        | A_c > A_s | A_corr = A      | P_c != P_s | A_min - 1         | 0
  * Buy         | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min - 1
  * Sell        | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min - 1
  * Buy         | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min - 1
  * Sell        | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min - 1
  * Buy         | A_c > A_s | A_corr = A      | P_c = P_s  | A_min             | 0
  * Sell        | A_c > A_s | A_corr = A      | P_c = P_s  | A_min             | 0
  * Buy         | A_c > A_s | A_corr = A      | P_c != P_s | A_min             | 0
  * Sell        | A_c > A_s | A_corr = A      | P_c != P_s | A_min             | 0
  * Buy         | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min
  * Sell        | A_c < A_s | A_corr = A      | P_c = P_s  | 0                 | A_min
  * Buy         | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min
  * Sell        | A_c < A_s | A_corr = A      | P_c != P_s | 0                 | A_min
  * Buy         | A_c = A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min - 1
  * Sell        | A_c = A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min - 1
  * Buy         | A_c < A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min
  * Sell        | A_c < A_s | A_corr < A      | P_c = P_s  | A_min - 1         | A_min
  * Buy         | A_c > A_s | A_corr < A      | P_c = P_s  | A_min             | A_min - 1
  * Sell        | A_c > A_s | A_corr < A      | P_c = P_s  | A_min             | A_min - 1
  */
class ReservedBalanceSpecification
    extends AnyPropSpecLike
    with MatcherSpecLike
    with WithDB
    with MatcherSpecBase
    with TableDrivenPropertyChecks
    with NTPTime {

  override protected def actorSystemName: String = getSimpleName(this)

  private implicit val efc: ErrorFormatterContext = (_: Asset) => 8
  private implicit val timeout: Timeout           = 5.seconds

  import com.wavesplatform.dex.util.Implicits._
  import system.dispatcher

  private val ignoreSpendableBalanceChanges: Subject[SpendableBalanceChanges, SpendableBalanceChanges] = Subject.empty[SpendableBalanceChanges]

  private val pair: AssetPair      = AssetPair(mkAssetId("WAVES"), mkAssetId("USD"))
  private var oh: OrderHistoryStub = new OrderHistoryStub(system, ntpTime)

  private val addressDir = system.actorOf(
    Props(
      new AddressDirectory(
        ignoreSpendableBalanceChanges,
        matcherSettings,
        EmptyOrderDB,
        (address, enableSchedules) =>
          Props(
            new AddressActor(
              address,
              _ => Future.successful(0L),
              ntpTime,
              new TestOrderDB(100),
              _ => Future.successful(false),
              _ => Future.failed(new IllegalStateException("Should not be used in the test")),
              orderBookCache = _ => AggregatedSnapshot(),
              enableSchedules
            )
        ),
        None
      )
    )
  )

  private def minAmountFor(price: Long, amountDecimals: Int = 8): Long = { BigDecimal(Math.pow(10, amountDecimals)) / BigDecimal(price) }
    .setScale(0, CEILING)
    .toLong

  private def openVolume(senderPublicKey: PublicKey, assetId: Asset, addressDirectory: ActorRef = addressDir): Long = {
    Await
      .result(
        (addressDirectory ? AddressDirectory
          .Envelope(senderPublicKey, AddressActor.Query.GetReservedBalance)).mapTo[AddressActor.Reply.Balance].map(_.balance),
        Duration.Inf
      )
      .getOrElse(assetId, 0L)
  }

  def execute(counter: Order, submitted: Order): OrderExecuted = {
    addressDir ! OrderAdded(LimitOrder(submitted), ntpTime.getTimestamp())
    addressDir ! OrderAdded(LimitOrder(counter), ntpTime.getTimestamp())

    oh.process(OrderAdded(LimitOrder(counter), ntpTime.getTimestamp()))
    val exec = OrderExecuted(LimitOrder(submitted), LimitOrder(counter), submitted.timestamp, submitted.matcherFee, counter.matcherFee)
    addressDir ! exec
    exec
  }

  override def beforeEach(): Unit = {
    super.beforeEach()
    oh = new OrderHistoryStub(system, ntpTime)
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.waves, 2.3.usd, 2.waves, 2.3.usd),
      (SELL, 2.waves, 2.3.usd, 2.waves, 2.3.usd),
      (BUY, 2.waves, 2.3.usd, 2.waves, 2.2.usd),
      (SELL, 2.waves, 2.2.usd, 2.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(s"Reserves should be 0 when remains are 0: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice") {
      val counter   = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      val exec      = execute(counter, submitted)

      withClue("Both orders should be filled") {
        exec.executedAmount shouldBe counter.amount
      }

      withClue("All remains should be 0") {
        exec.counterRemainingAmount shouldBe 0
        exec.submittedRemainingAmount shouldBe 0
      }

      withClue(s"Counter sender should not have reserves") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should not have reserves") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434782.waves, 2.3.usd, 2.waves, 2.3.usd),
      (SELL, 2.00434782.waves, 2.3.usd, 2.waves, 2.3.usd),
      (BUY, 2.00434782.waves, 2.3.usd, 2.waves, 2.2.usd),
      (SELL, 2.00454545.waves, 2.2.usd, 2.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter reserves should be 0 WHEN remain is (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter   = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      val exec      = execute(counter, submitted)

      withClue("Both orders should be filled") {
        exec.executedAmount shouldBe submittedAmount
      }

      withClue("Counter remain should be (minAmount - 1):") {
        exec.counterRemainingAmount shouldBe minAmountFor(counterPrice) - 1
        exec.submittedRemainingAmount shouldBe 0
      }

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
      (SELL, 2.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
      (BUY, 2.waves, 2.3.usd, 2.00454545.waves, 2.2.usd),
      (SELL, 2.waves, 2.2.usd, 2.00434782.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Submitted reserves should be 0 WHEN remain is (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter   = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      val exec      = execute(counter, submitted)

      withClue("Both orders should be filled") {
        exec.executedAmount shouldBe counterAmount
      }

      withClue("Submitted remain should be (minAmount - 1):") {
        exec.counterRemainingAmount shouldBe 0
        exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice) - 1
      }

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434783.waves, 2.3.usd, 2.waves, 2.3.usd),
      (SELL, 2.00434783.waves, 2.3.usd, 2.waves, 2.3.usd),
      (BUY, 2.00434783.waves, 2.3.usd, 2.waves, 2.2.usd),
      (SELL, 2.00454546.waves, 2.2.usd, 2.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter reserve should be minAmount WHEN remain is minAmount: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter   = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      val exec      = execute(counter, submitted)

      withClue("Counter should be partially filled:") {
        exec.executedAmount shouldBe submittedAmount
      }

      withClue("Counter remain should be minAmount:") {
        exec.counterRemainingAmount shouldBe minAmountFor(counterPrice)
        exec.submittedRemainingAmount shouldBe 0
      }

      withClue(s"Counter sender should have reserved asset:") {
        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (0, 1) else (minAmountFor(counterPrice), 0)
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.waves, 2.3.usd, 2.00434783.waves, 2.3.usd),
      (SELL, 2.waves, 2.3.usd, 2.00434783.waves, 2.3.usd),
      (BUY, 2.waves, 2.3.usd, 2.00454546.waves, 2.2.usd),
      (SELL, 2.waves, 2.2.usd, 2.00434783.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Submitted reserve should be minAmount WHEN remain is minAmount: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter   = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      val exec      = execute(counter, submitted)

      withClue("Submitted should be partially filled:") {
        exec.executedAmount shouldBe counterAmount
      }

      withClue("Submitted remain should be minAmount:") {
        exec.counterRemainingAmount shouldBe 0
        exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice)
      }

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should have reserved asset:") {
        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (minAmountFor(submittedPrice), 0) else (0, 1)
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434782.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
      (SELL, 2.00434782.waves, 2.3.usd, 2.00434782.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter and submitted reserves should be 0 WHEN both remains are (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter   = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      val exec      = execute(counter, submitted)

      exec.executedAmount shouldBe 2.waves

      exec.counterRemainingAmount shouldBe minAmountFor(counterPrice) - 1
      exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice) - 1

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434782.waves, 2.3.usd, 2.00434783.waves, 2.3.usd),
      (SELL, 2.00434782.waves, 2.3.usd, 2.00434783.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter and submitted reserves should be 0 and minAmount WHEN their remains are (minAmount - 1) and minAmount: $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter   = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      val exec      = execute(counter, submitted)

      exec.executedAmount shouldBe 2.waves

      exec.counterRemainingAmount shouldBe minAmountFor(counterPrice) - 1
      exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice)

      withClue(s"Counter sender should not have reserves:") {
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe 0
      }

      withClue(s"Submitted sender should have reserved asset:") {
        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (minAmountFor(submittedPrice), 0) else (0, 1)
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
      }
    }
  }

  forAll(
    Table(
      ("counter type", "counter amount", "counter price", "submitted amount", "submitted price"),
      (BUY, 2.00434783.waves, 2.3.usd, 2.00434782.waves, 2.3.usd),
      (SELL, 2.00434783.waves, 2.3.usd, 2.00434782.waves, 2.3.usd)
    )
  ) { (counterType: OrderType, counterAmount: Long, counterPrice: Long, submittedAmount: Long, submittedPrice: Long) =>
    property(
      s"Counter and submitted reserves should be minAmount and 0 WHEN their remains and minAmount are (minAmount - 1): $counterType $counterAmount/$counterPrice:$submittedAmount/$submittedPrice"
    ) {
      val counter   = if (counterType == BUY) rawBuy(pair, counterAmount, counterPrice) else rawSell(pair, counterAmount, counterPrice)
      val submitted = if (counterType == BUY) rawSell(pair, submittedAmount, submittedPrice) else rawBuy(pair, submittedAmount, submittedPrice)
      val exec      = execute(counter, submitted)

      exec.executedAmount shouldBe 2.waves

      exec.counterRemainingAmount shouldBe minAmountFor(counterPrice)
      exec.submittedRemainingAmount shouldBe minAmountFor(submittedPrice) - 1

      withClue(s"Counter sender should have reserved asset:") {
        val (expectedAmountReserve, expectedPriceReserve) = if (counterType == BUY) (0, 1) else (minAmountFor(submittedPrice), 0)
        openVolume(counter.senderPublicKey, pair.amountAsset) shouldBe expectedAmountReserve
        openVolume(counter.senderPublicKey, pair.priceAsset) shouldBe expectedPriceReserve
      }

      withClue(s"Submitted sender should not have reserves:") {
        openVolume(submitted.senderPublicKey, pair.amountAsset) shouldBe 0
        openVolume(submitted.senderPublicKey, pair.priceAsset) shouldBe 0
      }
    }
  }

  override val matcherFee = 1L

  private def printLimitOrderInfo(orderType: OrderType, amount: Long, price: Long): String = {
    val denormalizedAmount = pair.amountAsset.dAmt(amount)
    val denormalizedPrice  = pair.priceAsset.dAmt(price)
    s"LIMIT $orderType $denormalizedAmount ${pair.amountAsset.toStringWUE} @ $denormalizedPrice ${pair.priceAsset.toStringWUE}"
  }

  private def printMarketOrderInfo(orderType: OrderType, amount: Long, price: Long, feeAsset: Asset, spendableBalance: Map[Asset, Long]): String = {
    val spendableBalanceStr = spendableBalance.map { case (asset, balance) => asset.toStringWUE -> asset.dAmt(balance) }.toString
    val denormalizedAmount  = pair.amountAsset.dAmt(amount)
    val denormalizedPrice   = pair.priceAsset.dAmt(price)

    s"MARKET $orderType $denormalizedAmount ${pair.amountAsset.toStringWUE} @ $denormalizedPrice ${pair.priceAsset.toStringWUE}, " +
      s"fee in ${feeAsset.toStringSRT(orderType)} asset ($matcherFee ${feeAsset.toStringWUE}), spendable balance = $spendableBalanceStr"
  }

  private implicit class AssetOps(asset: Asset) {
    def toStringSRT(orderType: OrderType): String = orderType match {
      case OrderType.BUY  => if (asset == pair.priceAsset) "spent" else if (asset == pair.amountAsset) "received" else "third"
      case OrderType.SELL => if (asset == pair.amountAsset) "spent" else if (asset == pair.priceAsset) "received" else "third"
    }

    def toStringWUE: String = asset match {
      case WAVES => "WAVES"
      case USD   => "USD"
      case ETH   => "ETH"
      case _     => "wtf"
    }

    def amt(value: Long): Long = asset match {
      case WAVES => value.waves
      case USD   => value.usd
      case ETH   => value.eth
      case _     => value
    }

    def dAmt(value: Long): BigDecimal = asset match {
      case WAVES => BigDecimal(value) / Order.PriceConstant
      case USD   => BigDecimal(value) / 100
      case ETH   => BigDecimal(value) / Order.PriceConstant
      case _     => value
    }
  }

  private val WAVES = pair.amountAsset
  private val USD   = pair.priceAsset
  private val ETH   = mkAssetId("ETH")

  private def addressDirWithSpendableBalance(spendableBalance: Asset => Future[Long],
                                             orderBookCache: AssetPair => AggregatedSnapshot = _ => AggregatedSnapshot(),
                                             testProbe: TestProbe): ActorRef = {
    system.actorOf(
      Props(
        new AddressDirectory(
          ignoreSpendableBalanceChanges,
          matcherSettings,
          new TestOrderDB(100),
          (address, enableSchedules) =>
            Props(
              new AddressActor(
                owner = address,
                spendableBalance = spendableBalance,
                time = ntpTime,
                orderDB = new TestOrderDB(100),
                hasOrderInBlockchain = _ => Future.successful(false),
                store = event => {
                  testProbe.ref ! event
                  Future.successful { Some(QueueEventWithMeta(0, System.currentTimeMillis, event)) }
                },
                orderBookCache = orderBookCache,
                enableSchedules
              )
          ),
          None
        )
      )
    )
  }

  private def placeMarketOrder(tp: TestProbe, addressDir: ActorRef, marketOrder: MarketOrder): Unit = {
    tp.send(addressDir, Envelope(marketOrder.order.senderPublicKey, PlaceOrder(marketOrder.order, isMarket = true)))
  }

  private def systemCancelMarketOrder(addressDir: ActorRef, marketOrder: MarketOrder): Unit = {
    addressDir ! OrderCanceled(marketOrder, isSystemCancel = true, System.currentTimeMillis)
  }

  private def executeMarketOrder(addressDirWithOrderBookCache: ActorRef, marketOrder: MarketOrder, limitOrder: LimitOrder): OrderExecuted = {
    val executionEvent = OrderExecuted(marketOrder, limitOrder, marketOrder.order.timestamp, marketOrder.matcherFee, limitOrder.matcherFee)

    addressDirWithOrderBookCache ! OrderAdded(limitOrder, ntpTime.getTimestamp())
    addressDirWithOrderBookCache ! executionEvent

    executionEvent
  }

  private def amtMap(waves: Long = 0L, usd: Long = 0L, eth: Long = 0L): Map[Asset, Long] = Map(WAVES -> waves, USD -> usd, ETH -> eth)

  // noinspection ScalaStyle
  forAll(
    Table(
      ("market order type", "amount", "price", "fee asset", "spendable balance", "reserves map after placement"),
      /** BUY, availableForSpending > required by spendable asset */
      (BUY, 123.waves, 3.usd, USD, amtMap(500.waves, 500.usd, 50.eth), amtMap(usd = 370.usd)), // fee in spent asset
      (BUY, 123.waves, 3.usd, WAVES, amtMap(500.waves, 500.usd, 50.eth), amtMap(usd = 369.usd)), // fee in received asset
      (BUY, 0.1.waves, 3.usd, WAVES, amtMap(500.waves, 500.usd, 50.eth), amtMap(waves = 0.9.waves, usd = 0.3.usd)), // fee in received asset, received amount < fee
      (BUY, 123.waves, 3.usd, ETH, amtMap(500.waves, 500.usd, 50.eth), amtMap(usd = 369.usd, eth = 1.eth)),         // fee in third asset
      /** SELL, availableForSpending > required by spendable asset  */
      (SELL, 123.waves, 3.usd, WAVES, amtMap(500.waves, 500.usd, 50.eth), amtMap(waves = 124.waves)), // fee in spent asset
      (SELL, 123.waves, 3.usd, USD, amtMap(500.waves, 500.usd, 50.eth), amtMap(waves = 123.waves)), // fee in received asset
      (SELL, 0.1.waves, 3.usd, USD, amtMap(500.waves, 500.usd, 50.eth), amtMap(waves = 0.1.waves, usd = 0.7.usd)), // fee in received asset, received amount < fee
      (SELL, 123.waves, 3.usd, ETH, amtMap(500.waves, 500.usd, 50.eth), amtMap(waves = 123.waves, eth = 1.eth)),   // fee in third asset
      /**
        * BUY, availableForSpending < required by spendable asset
        * Note:
        *  - (BUY, 0.1.waves, 3.usd, USD,   amtMap(500.waves, 0.9.usd, 50.eth))  - required 1.usd (marketOrderVolume = 0, only fee required),   balance = 0.9.usd,   received amount = 0.0.usd,   BalanceNotEnough by USD
        *  - (BUY, 0.1.waves, 3.usd, WAVES, amtMap(0.8.waves, 500.usd, 50.eth))  - required 1.waves (marketOrderVolume = 0, only fee required), balance = 0.8.waves, received amount = 0.1.waves, BalanceNotEnough by WAVES
        *  - (BUY, 123.waves, 3.usd, ETH,   amtMap(500.waves, 500.usd, 0.9.eth)) - required 1.eth,                                              balance = 0.9.eth,   received amount = 0.0.eth,   BalanceNotEnough by ETH
        */
      (BUY, 123.waves, 3.usd, USD, amtMap(500.waves, 300.usd, 50.eth), amtMap(usd = 300.usd)), // fee in spent asset
      (BUY, 123.waves, 3.usd, WAVES, amtMap(500.waves, 300.usd, 50.eth), amtMap(usd = 300.usd)),                      // fee in received asset
      (BUY, 0.1.waves, 3.usd, WAVES, amtMap(500.waves, 0.15.usd, 50.eth), amtMap(waves = 0.9.waves, usd = 0.15.usd)), // fee in received asset, received amount < fee
      /**
        * SELL, availableForSpending < required by spendable asset
        * Note:
        *  - (SELL, 0.1.waves, 3.usd, WAVES, amtMap(0.9.waves, 500.usd, 50.eth))  - required 1.waves (marketOrderVolume = 0, only fee required), balance = 0.9.waves, received amount = 0.0.waves, BalanceNotEnough by WAVES
        *  - (SELL, 0.1.waves, 3.usd, USD,   amtMap(500.waves, 0.6.usd, 50.eth))  - required 1.usd (marketOrderVolume = 0, only fee required),   balance = 0.6.usd,   received amount = 0.3.usd,   BalanceNotEnough by USD
        *  - (SELL, 123.waves, 3.usd, ETH,   amtMap(500.waves, 500.usd, 0.9.eth)) - required 1.eth,                                              balance = 0.9.eth,   received amount = 0.0.eth,   BalanceNotEnough by ETH
        */
      (SELL, 123.waves, 3.usd, WAVES, amtMap(100.waves, 500.usd, 50.eth), amtMap(waves = 100.waves)), // fee in spent asset
      (SELL, 123.waves, 3.usd, USD, amtMap(100.waves, 500.usd, 50.eth), amtMap(waves = 100.waves)), // fee in received asset
      (SELL, 0.1.waves, 3.usd, USD, amtMap(0.05.waves, 500.usd, 50.eth), amtMap(waves = 0.05.waves, usd = 0.7.usd)) // fee in received asset, received amount < fee
    )
  ) { (orderType: OrderType, amount: Long, price: Long, feeAsset: Asset, balance: Map[Asset, Long], reserves: Map[Asset, Long]) =>
    property {
      s"Reserves of the market order with no counters should be correct: ${printMarketOrderInfo(orderType, amount, price, feeAsset, balance)}"
    } {

      val tp         = TestProbe()
      val addressDir = addressDirWithSpendableBalance(balance.mapValues(Future.successful), testProbe = tp)
      val fee        = Some(feeAsset.amt(matcherFee))

      val order = orderType match {
        case BUY  => rawBuy(pair, amount, price, version = 3, feeAsset = feeAsset, matcherFee = fee)
        case SELL => rawSell(pair, amount, price, version = 3, feeAsset = feeAsset, matcherFee = fee)
      }

      def reservedBalanceBy(asset: Asset): Long = openVolume(order.senderPublicKey, asset, addressDir)

      val marketOrder                 = MarketOrder(order, balance)
      val expectedSpentAssetReserve   = reserves(marketOrder.spentAsset)
      val expectedReceiveAssetReserve = reserves(marketOrder.rcvAsset)
      val expectedFeeAssetReserve     = reserves(marketOrder.feeAsset)

      placeMarketOrder(tp, addressDir, marketOrder)
      tp.expectMsg(QueueEvent.PlacedMarket(marketOrder))

      withClue {
        s"Place market $orderType order, fee in ${feeAsset.toStringSRT(orderType)} asset, expected reserves (spent/received/fee) = $expectedSpentAssetReserve/$expectedReceiveAssetReserve/$expectedFeeAssetReserve:\n"
      } {
        reservedBalanceBy(marketOrder.spentAsset) shouldBe expectedSpentAssetReserve
        reservedBalanceBy(marketOrder.rcvAsset) shouldBe expectedReceiveAssetReserve
        reservedBalanceBy(marketOrder.feeAsset) shouldBe expectedFeeAssetReserve
      }

      systemCancelMarketOrder(addressDir, marketOrder)

      withClue(s"System cancel of $orderType market order:\n") {
        reservedBalanceBy(marketOrder.spentAsset) shouldBe 0
        reservedBalanceBy(marketOrder.rcvAsset) shouldBe 0
        reservedBalanceBy(marketOrder.feeAsset) shouldBe 0
      }
    }
  }

  // noinspection ScalaStyle
  forAll(
    Table(
      ("mo type", "mo amount", "mo price", "mo fee asset", "spendable balance", "lo amount", "lo price", "reserves map after execution"),
      /** r = required, f = fee, ea = executed amount, ef = executed fee, afs = available for spending, ea*, ef* = calculated by the formula AcceptedOrder.executedAmount */
      /** market BUY order PARTIALLY filled, available for spending > required by spendable asset */
      (BUY, 123.waves, 3.usd, USD, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 2.usd, amtMap(usd = 169.19.usd)), // fee in spent asset,    USD: 123 * 3 [r] + 1 [f] - 100 * 2 [ea] - 100/123 [ef]
      (BUY, 123.waves, 3.usd, WAVES, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 2.usd, amtMap(usd = 169.usd)),                     // fee in received asset, USD: 123 * 3 [r] - 100 * 2 [ea]
      (BUY, 123.waves, 3.usd, ETH, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 2.usd, amtMap(usd = 169.usd, eth = 0.18699187.eth)), // fee in third asset,    USD: 123 * 3 [r] - 100 * 2 [ea], ETH: 1 [f] - 100/123 [ef]
      /** market BUY order filled, available for spending > required by spendable asset */
      (BUY, 100.waves, 3.usd, USD, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in spent asset
      (BUY, 100.waves, 3.usd, WAVES, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in received asset
      (BUY, 100.waves, 3.usd, ETH, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 2.usd, amtMap()),   // fee in third asset
      /** market SELL order PARTIALLY filled, available for spending > required by spendable asset */
      (SELL, 123.waves, 2.usd, WAVES, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(waves = 23.18699187.waves)), // fee in spent asset,    WAVES: 123 [r] + 1 [f] - 100 [ea] - 100/123 [ef]
      (SELL, 123.waves, 2.usd, USD, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(waves = 23.waves)),                       // fee in received asset, WAVES: 123 [r] - 100 [ea]
      (SELL, 123.waves, 2.usd, ETH, amtMap(500.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(waves = 23.waves, eth = 0.18699187.eth)), // fee in third asset,    WAVES: 123 [r] - 100 [ea], ETH: 1 [f] - 100/123 [ef]
      /** market SELL order filled, available for spending > required by spendable asset */
      (SELL, 100.waves, 2.usd, WAVES, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 3.usd, amtMap()), // fee in spent asset
      (SELL, 100.waves, 2.usd, USD, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 3.usd, amtMap()), // fee in received asset
      (SELL, 100.waves, 2.usd, ETH, amtMap(500.waves, 500.usd, 50.eth), 200.waves, 3.usd, amtMap()), // fee in third asset
      /** market BUY order PARTIALLY filled, available for spending < required by spendable asset, but is enough to cover market cost and fee */
      (BUY, 123.waves, 3.usd, USD, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 2.usd, amtMap(usd = 99.19.usd)), // fee in spent asset,    USD: 300 [afs] - 100 * 2 [ea] - 100/123 [ef]
      (BUY, 123.waves, 3.usd, WAVES, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 2.usd, amtMap(usd = 100.usd)),                     // fee in received asset, USD: 300 [afs] - 100 * 2 [ea]
      (BUY, 123.waves, 3.usd, ETH, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 2.usd, amtMap(usd = 100.usd, eth = 0.18699187.eth)), // fee in third asset,    USD: 300 [afs] - 100 * 2 [ea], ETH: 1 [f] - 100/123 [ef]
      /** (!!!) market BUY order PARTIALLY filled, available for spending < required by spendable asset and is NOT enough to cover market cost and fee */
      (BUY, 100.waves, 3.usd, USD, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 3.usd, amtMap(usd = 0.01.usd)), // fee in spent asset,    USD: 300 [afs] - 299.00 [ea*] - 0.99 [ef*]
      (BUY, 100.waves, 3.usd, USD, amtMap(500.waves, 290.usd, 50.eth), 100.waves, 3.usd, amtMap(usd = 0.01.usd)), // fee in spent asset,    USD: 290 [afs] - 289.03 [ea*] - 0.96 [ef*]
      (BUY, 100.waves, 3.usd, WAVES, amtMap(500.waves, 290.usd, 50.eth), 100.waves, 3.usd, amtMap(usd = 0.01.usd)),                     // fee in received asset, USD: 290 [afs] - 299.99 [ea*]
      (BUY, 100.waves, 3.usd, ETH, amtMap(500.waves, 290.usd, 50.eth), 100.waves, 3.usd, amtMap(usd = 0.01.usd, eth = 0.03336667.eth)), // fee in third asset,    USD: 290 [afs] - 289.99 [ea*], ETH = 1 [f] - 0.96663333 [ef*]
      /** market BUY order filled, available for spending = required by spendable asset */
      (BUY, 100.waves, 3.usd, USD, amtMap(500.waves, 301.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in spent asset
      (BUY, 100.waves, 3.usd, WAVES, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in received asset
      (BUY, 100.waves, 3.usd, ETH, amtMap(500.waves, 300.usd, 50.eth), 100.waves, 3.usd, amtMap()),   // fee in third asset
      /** market BUY order filled, available for spending < required by spendable asset */
      (BUY, 100.waves, 3.usd, USD, amtMap(500.waves, 250.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in spent asset
      (BUY, 100.waves, 3.usd, WAVES, amtMap(500.waves, 250.usd, 50.eth), 200.waves, 2.usd, amtMap()), // fee in received asset
      (BUY, 100.waves, 3.usd, ETH, amtMap(500.waves, 250.usd, 50.eth), 200.waves, 2.usd, amtMap()),   // fee in third asset
      /** market SELL order PARTIALLY filled, available for spending < required by spendable asset but is enough to cover market amount and fee */
      (SELL, 123.waves, 2.usd, WAVES, amtMap(110.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(waves = 9.18699187.waves)), // fee in spent asset,    WAVES: 110 [afs] - 100 [ea] - 100/123 [ef]
      (SELL, 123.waves, 2.usd, USD, amtMap(110.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(waves = 10.waves)),                       // fee in received asset, WAVES: 110 [afs] - 100 [ea]
      (SELL, 123.waves, 2.usd, ETH, amtMap(110.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(waves = 10.waves, eth = 0.18699187.eth)), // fee in third asset,    WAVES: 110 [afs] - 100 [ea], USD: 1 [f] - 100/123 [ef]
      /** (!!!) market SELL order PARTIALLY filled, available for spending < required by spendable asset and NOT enough to cover market amount and fee */
      (SELL, 123.waves, 2.usd, WAVES, amtMap(100.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(waves = 0.00000001.waves)), // fee in spent asset, WAVES: 100 [afs] - 99.19354838 [ea*] - 0.80645161 [ef*]
      (SELL, 123.waves, 2.usd, WAVES, amtMap(90.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(waves = 0.00000001.waves)), // fee in spent asset, WAVES:  90 [afs] - 89.27419354 [ea*] - 0.72580645 [ef*]
      (SELL, 123.waves, 2.usd, USD, amtMap(90.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()),                     // fee in received asset
      (SELL, 123.waves, 2.usd, ETH, amtMap(90.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap(eth = 0.26829269.eth)), // fee in third asset, ETH: 1 [f] - 90/123 [ef]
      /** market SELL order filled, available for spending = required by spendable asset */
      (SELL, 100.waves, 3.usd, WAVES, amtMap(101.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in spent asset
      (SELL, 100.waves, 3.usd, USD, amtMap(100.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()), // fee in received asset
      (SELL, 100.waves, 3.usd, ETH, amtMap(100.waves, 500.usd, 50.eth), 100.waves, 3.usd, amtMap()) // fee in third asset
      /** market SELL order filled, available for spending < required by spendable asset - impossible case */
    )
  ) {
    (moTpe: OrderType, moAmt: Long, moPrc: Long, moFeeAsst: Asset, balance: Map[Asset, Long], loAmt: Long, loPrc: Long, reserves: Map[Asset, Long]) =>
      property {
        s"Reserves of the market order (${printMarketOrderInfo(moTpe, moAmt, moPrc, moFeeAsst, balance)}) executed with the counter order (${printLimitOrderInfo(moTpe.opposite, loAmt, loPrc)}) should be correct"
      } {

        val orderBookCache: AssetPair => AggregatedSnapshot = _ => {
          val levels = Seq(LevelAgg(loAmt, loPrc))
          moTpe match {
            case BUY  => AggregatedSnapshot(asks = levels)
            case SELL => AggregatedSnapshot(bids = levels)
          }
        }

        val tp         = TestProbe()
        val addressDir = addressDirWithSpendableBalance(balance.mapValues { Future.successful }, orderBookCache, tp)
        val fee        = Some(moFeeAsst.amt(matcherFee))

        val (order, counter) = moTpe match {
          case BUY  => rawBuy(pair, moAmt, moPrc, version = 3, feeAsset = moFeeAsst, matcherFee = fee)  -> rawSell(pair, loAmt, loPrc)
          case SELL => rawSell(pair, moAmt, moPrc, version = 3, feeAsset = moFeeAsst, matcherFee = fee) -> rawBuy(pair, loAmt, loPrc)
        }

        def reservedBalanceBy(asset: Asset): Long = openVolume(order.senderPublicKey, asset, addressDir)

        val marketOrder = MarketOrder(order, balance)

        placeMarketOrder(tp, addressDir, marketOrder)

        // here Try because of the market order nature:
        // an order can pass validation, but during execution, available for spending balance may become not sufficient
        // because of order book changing.
        //
        // So in tests marked with !!! after order placement test probe won't receive PlacedMarket event,
        // since order will be rejected because of the BalanceNotEnough error. Its ok since in these tests we check
        // tricky cases of balance reservation, when afs is not enough to cover market value and fee

        tp.expectMsgAnyClassOf(300.millisecond, classOf[QueueEvent.PlacedMarket], classOf[OrderRejected])

        val orderExecutedEvent = executeMarketOrder(addressDir, marketOrder, LimitOrder(counter))

        val expectedSpentAssetReserve   = reserves(marketOrder.spentAsset)
        val expectedReceiveAssetReserve = reserves(marketOrder.rcvAsset)
        val expectedFeeAssetReserve     = reserves(marketOrder.feeAsset)

        withClue {
          s"Execution:\n" +
            s"MARKET $moTpe ($moAmt ${pair.amountAsset.toStringWUE} @ $moPrc ${pair.priceAsset.toStringWUE}, " +
            s"fee = ${moFeeAsst.amt(matcherFee)} ${moFeeAsst.toStringWUE}, " +
            s"afs = ${marketOrder.availableForSpending} ${marketOrder.spentAsset.toStringWUE}),\n" +
            s"LIMIT ${moTpe.opposite} ($loAmt ${pair.amountAsset.toStringWUE} @ $loPrc ${pair.priceAsset.toStringWUE}),\n" +
            s"expected reserves after execution (spent/received/fee) = " +
            s"$expectedSpentAssetReserve/$expectedReceiveAssetReserve/$expectedFeeAssetReserve:\n"
        } {
          reservedBalanceBy(marketOrder.spentAsset) shouldBe expectedSpentAssetReserve
          reservedBalanceBy(marketOrder.rcvAsset) shouldBe expectedReceiveAssetReserve
          reservedBalanceBy(marketOrder.feeAsset) shouldBe expectedFeeAssetReserve
        }

        systemCancelMarketOrder(addressDir, orderExecutedEvent.submittedMarketRemaining(marketOrder))

        withClue(s"System cancel of $moTpe market order remaining:\n") {
          reservedBalanceBy(marketOrder.spentAsset) shouldBe 0
          reservedBalanceBy(marketOrder.rcvAsset) shouldBe 0
          reservedBalanceBy(marketOrder.feeAsset) shouldBe 0
        }
      }
  }
}
